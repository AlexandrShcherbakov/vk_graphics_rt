#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require

#include "unpack_attributes.h"

layout(binding = 0, set = 0) uniform accelerationStructureEXT m_pAccelStruct;

layout(binding = 1, set = 0) buffer lighting_buf { float lighting[]; };

bool m_pAccelStruct_RayQuery_NearestHit(const vec3 rayPos, const vec3 rayDir, float len)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsOpaqueEXT, 0xff, rayPos.xyz, 0, rayDir.xyz, len);
  
  while(rayQueryProceedEXT(rayQuery)) { }
 

  return (rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionTriangleEXT);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout( push_constant ) uniform kernelArgs
{
  vec3 bmin;
  uint voxelsCount;
  vec3 bmax;
  float voxelSize;
  vec3 lightPos;
} kgenArgs;

shared vec3 arrayToConv[256];

void main()
{
  uint voxelId = uint(gl_GlobalInvocationID[0]);
  uvec3 voxelsExtend = uvec3(ceil((kgenArgs.bmax - kgenArgs.bmin) / kgenArgs.voxelSize));
  if (voxelId >= voxelsExtend.x * voxelsExtend.y * voxelsExtend.z)
    return;

  uvec3 voxelIdx = uvec3(voxelId / voxelsExtend.z / voxelsExtend.y, voxelId / voxelsExtend.z % voxelsExtend.y, voxelId % voxelsExtend.z);
  vec3 center = kgenArgs.bmin + (voxelIdx + 0.5) * kgenArgs.voxelSize;
  vec3 positiveLight = vec3(0);
  vec3 negativeLight = vec3(0);
  const int perAxisCnt = 4;
  for (int x = 0; x < perAxisCnt; ++x)
    for (int y = 0; y < perAxisCnt; ++y)
      for (int z = 0; z < perAxisCnt; ++z)
      {
        vec3 offset = vec3(x, y, z) / perAxisCnt - 0.5;
        vec3 pos = center + offset * kgenArgs.voxelSize;
        vec3 toLight = kgenArgs.lightPos - pos;
        float toLightDist = length(toLight);
        vec3 toLightDir = toLight / toLightDist;
        if (m_pAccelStruct_RayQuery_NearestHit(pos, toLightDir, toLightDist))
        {
          positiveLight += max(vec3(0), toLightDir);
          negativeLight += max(vec3(0), -toLightDir);
        }
      }
  for (int i = 0; i < 3; ++i)
  {
    lighting[voxelId * 6 + i] = positiveLight[i] / perAxisCnt / perAxisCnt / perAxisCnt;
    lighting[voxelId * 6 + 3 + i] = negativeLight[i] / perAxisCnt / perAxisCnt / perAxisCnt;
  }
  
}

